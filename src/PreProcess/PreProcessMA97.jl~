type PDataMA97 <: PDataFact
    PLD :: Ma97          # H = (PL)D(PL)'  or  LDL' = P'HP
    Δ::Array{Float64,1}  # diagonal, eigenvalues of D
    D
    H
    pivot
    #Q::Array{Float64,2}  # orthogonal matrix, eigenvectors of D:  should be sparse
                         # QΔQ'  =  D
    Q::SparseMatrixCSC{Float64,Int64}
    g̃::Array{Float64,1}  # transformed gradient 
    g::Array{Float64,1}  # untransformed gradient 
    λ::Float64
    success::Bool        # previous iteration was successfull
    OK::Bool

    PDataMA97() = new()
    PDataMA97(PLD,Δ,D,H,pivot,Q,g̃,g,l,success,OK) = new(PLD,Δ,D,H,pivot,Q,g̃,g,l,success,OK)
end


#@debug 
function preprocessMA97(H ,g, params::Tparams,n1,n2)
    global PLD, ret, vD1, vD2, pivot, vD
    try
        PLD = Ma97(H)
        #PLD.control.print_level = -1
        ma97_factorize(PLD)
        #ret = ma97_inquire(PLD)
    catch
 	println("*******   Problem in MA97")
        res = PDataMA97()
        res.OK = false
        return res
    end

    try
#@bp
        ret = ma97_inquire(PLD)
        vD = ret[2]
        pivot = ret[1]
        z(a)= a==0
        pivot[find(z,pivot)] = collect(1:length(pivot))[find(z,pivot)]
        #p_min, = findmin(abs(pivot))
        #p_max, = findmax(pivot)

        #assert(p_min>0)
        #vD1 = vD[1,abs(pivot)]'[:,1]
        #vD2 = vD[2,abs(pivot[1:end-1])]'[:,1]
        vD1 = copy(vD[1,:])'[:,1]
        vD2 = copy(vD[2,1:end-1])'[:,1]
    catch
 	println("*******   Problem after MA97")
        println(" Cond(H) = $(cond(full(H)))")
        #lm=findmin(D);lM=findmax(D)
        #println("λ min (H) = $lm  λ max (H) = $lM")
        res = PDataMA97()
        res.OK = false
        return res
    end

    D = spdiagm((vD1,vD2,vD2),[0 -1 1]) # don't forget inquire returns D^-1

    #DiagD, Q = eig(full(D))             # Revise to avoid full(D)

    #################  Future object BlockDiag operator?
    vQ1 = ones(vD1)       # vector representation of orthogonal matrix Q
    vQ2 = zeros(vD2)      #
    vQ2 = zeros(vD2)      #
    vQ2m = zeros(vD2)      #
    veig = copy(vD1)      # vector of eigenvalues of D, initialized to diagonal of D
                          # if D diagonal, nothing more will be computed
    
    i=1;
    while i<length(vD1)
        if vD2[i] == 0.0
            i += 1
        else
            mA = [vD1[i] vD2[i];vD2[i] vD1[i+1]]  #  2X2 submatrix
            DiagmA, Qma = eig(mA)                 #  spectral decomposition of mA
            veig[i] = DiagmA[1]
            vQ1[i] = Qma[1,1]
            vQ2[i] = Qma[1,2]
            vQ2m[i] = Qma[2,1]
            vQ1[i+1] = Qma[2,2]
            veig[i+1] = DiagmA[2]
            i += 2
        end  
    end

    Q = spdiagm((vQ1,vQ2m,vQ2),[0,-1,1])           # sparse representation of Q
    ###########
    #@bp
    Q = Q[abs(pivot),abs(pivot)]
    veig = veig[abs(pivot)]

    #  tests with eig
    #DiagD, Qf= eig(full(D))
    #println(" PreProcess MA97  norm(full(Q)-Qf) = $(norm(full(Q)-Qf))")
    #println(" PreProcess MA97  norm(DiagD-S veig) = $(norm(DiagD-sort(veig)))")
    #println(" PreProcess MA97  norm(Qf*diagm(DiagD)*Qf' - D) = $(norm(Qf*diagm(DiagD)*Qf' - D))")
    #println(" PreProcess MA97  norm(Q*spdiagm(veig)*Q' - D[abs(pivot),abs(pivot)]) = $(norm(Q*diagm(veig)*Q' - D[abs(pivot),abs(pivot)]))")
    #println(" PreProcess MA97  norm(full(Q)*diagm(veig)*full(Q)' - full(D)) = $(norm(Q*diagm(veig)*Q' - D))")

#@bp


    Δ =  1.0  ./ veig #'[:,1]             # don't forget inquire returns D^-1
    l_m, = findmin(Δ)

    ĝ = copy(g)
    ma97_solve!(PLD, ĝ, job=:PL)

    g̃ = Q'*ĝ

    #if (norm(Q*g̃ - ĝ) > 1e-10*norm(ĝ))  @bp end


    λ =  max(-l_m,0.0) #max((-ϵ-1)*l_m,ϵ)
    return  PDataMA97(PLD,Δ,D,H,pivot,Q,g̃,g,λ,true,true)
end


#@debug 
function TtildeInv(X :: PDataMA97, d̃ ::  Array{Float64,1})
    #return X.P'*(X.L'\(X.Q*d̃))  #(X.Q * X.L' * X.P)\d̃
    d̂ = X.Q * d̃
#    ĝ = X.Q * X.g̃
#    println("*******TtildeInv:  g̃⋅d̃ = $(X.g̃⋅d̃), 0.5 d̃'X.Δd̃ = $(0.5*(X.Δ .* d̃)⋅d̃)")    
#    println("*******TtildeInv:  ĝ⋅d̂ = $(ĝ⋅d̂), 0.5 d̂'X.Dd̂ = $(0.5*(X.D[abs(X.pivot),abs(X.pivot)] \ d̂)⋅d̂)")    

    ma97_solve!(X.PLD, d̂, job=:LPS)
#    println("*******TtildeInv:  X.g⋅d̂ = $(X.g⋅d̂), 0.5 d̂'X.Hd̂ = $(0.5*(X.H * d̂)⋅d̂)")    
#@bp
    return d̂
end

function reconstructH(X :: PDataMA97)
    return X.P'*X.L*X.D*X.L'*X.P
end
