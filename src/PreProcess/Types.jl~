abstract TPData  # Ancestor of all PreProcess data

abstract PDataFact <: TPData  # Variants using matricial factorization

abstract PDataIter <: TPData  # Variants using iterative (Krylov) solvers

abstract Tparams  # Ancestor of variant specific parameters

type Tparam <: Tparams
end

type PDataK <: PDataIter
    d :: Array{Float64,1}
    λ :: Float64
    τ :: Float64  # Inexact Newton order parameter: stop when ||∇q||<||g||^(1+τ)

    indmin :: Int
    
    positives
    xShift
    shifts :: Array{Float64,1}
    nshifts :: Int
    norm_dirs :: Array{Float64,1}
    OK :: Bool
end


type PDataST <: PDataIter
    H # Hessian representation, most likely as a linear operator or a sparse matrix
    g # gradient vector
    τ :: Float64  # Inexact Newton order parameter: stop when ||∇q||<||g||^(1+τ)
    
    OK :: Bool
end

type PDataLDLt <: PDataFact
    L::Array{Float64,2}  # could be sparse
    D::Array{Float64,2}  # block diagonal 1X1 and 2X2
    P::Array{Float64,2}  # permutation matrix: should be vector
                         # LDL' = PHP'
    Δ::Array{Float64,1}  # diagonal, eigenvalues of D
    Q::Array{Float64,2}  # orthogonal matrix, eigenvectors of D:  should be sparse
                         # QΔQ'  =  D
    g̃::Array{Float64,1}  # transformed gradient 
    λ::Float64
    OK::Bool

    PDataLDLt() = new()
    PDataLDLt(L,D,P,DiagD,Q,g,l,OK) = new(L,D,P,DiagD,Q,g,l,OK)
end

type PDataSpectral <: PDataFact
    V::Array{Float64,2}   # orthogonal matrix
    Δ::Array{Float64,1}   # eigenvalues of Hessian matrix
    g̃::Array{Float64,1}   # transformed gradient 
    λ::Float64
    OK::Bool

    PDataSpectral() = new()
    PDataSpectral(V,Λ,g,l,OK) = new(V,Λ,g,l,OK)
end
